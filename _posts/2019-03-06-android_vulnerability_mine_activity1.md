---
layout: post
title: "android Activity漏洞挖掘"
date: 2019-03-06
category: android安全
tags: android安全
---

## 越权绕过漏洞
	
在Android系统中，Activity默认是不导出的，如果设置了 ```exported="true"``` 这样的关键值或者是添加了```<intent-filter>```这样的属性，并且没有显示的设置为```exported="false"```,那么此时Activity是导出的，如果Activity被不合理的导出，那么就会有越权绕过或者是泄漏敏感信息等安全风险，比如在业务过程中会有一些敏感的界面是需要用户输入密码才能查看的，但是如果没有对调起此activity的组件进行权限验证，那么就会造成验证的越权问题，导致恶意的攻击者不需要输入密码等信息也可以打开这个界面。还有通过Intent给Activity传输畸形数据使得程序崩溃拒绝服务影响用户体验或Activity界面被劫持产生欺诈等安全事件。  

## 利用

	1.启动 通过启动主界面子界面，在返回即可进入主界面。
	2.启动设置本地的密码的activity，可重置本地密码。

## 防护
	
	私有Activity，不应被其他应用启动相对是安全的，设置exported属性为false

	公开暴露的Activity，可以被任意应用启动：
	1.设置exported属性为true
	2.谨慎处理接收的intent
	3.有返回数据时不应包含敏感信息
	4.不应发送敏感信息
	5.当收到返回数据时谨慎处理

## 组件导出导致钓鱼欺诈

	Android为了提高用户的用户体验，对于不同的应用程序之间的切换，基本上是无缝。他们切换的只是一个activity，让切换的到前台显示，另一个应用则被覆盖到后台，不可见。Activity的概念相当于一个与用户交互的界面。  
	而Activity的调度是交由Android系统中的AMS管理的。AMS即ActivityManagerService(Activity管理服务),各个应用想启动或停止一个进程，都是先报告给AMS。  
	当AMS收到要启动或停止Activity的消息时，它先更新内部记录，在通知相应的进程运行或停止指定的Activity。当新的Activity启动，前一个Activity就会停止，这些Activity都保留在系统中年的Activity历史栈中。每有一个Activity启动，它就压入历史栈顶，并在手机上显示。  
	当用户按下back键时，顶部Activity弹出，恢复前一个Activity，栈顶指向当前的Activity。  
	由于Activity的这种特性，如果在启动一个Activity时，给它加入一个标志位FLAGACTIVITYNEW_TASK,就能使它置于栈顶并立马呈现给用户。  
	如果这个Activity是用于盗号的伪装Activity，那么就会产生钓鱼安全事件或者是一个Activity中有webview加载，如果允许加载任意网页也有可能会产生钓鱼事件。  

---

	public class LockTask extends TimerTask{
		public static final String TAG="LockTask";
		private Context mContext;
		String testPackageName="com.taobao.taobao";
		String testClassName="com.taobao.tao.LoginActivity";

		private ActivityManager mActivityManager;

		public LockTask(Context context){
			mContext=context;
			mActivityManager=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
		}

		@Override
		public void run(){
			ComponentName topActivity=mActivityManager.getRunningTasks(1).get(0).topActivity;
			String packageName = topActivity.getPackageName();
			String className = topActivity.getClassName();
			Log.v(TAG,"packageName"+packageName);
			Log.v(TAG,"className"+className);

			if(testPackageName.equals(packageName)&&testClassName.equals(className)){
				Intent intent = new Intent();
				intent.setClassName("com.example.locktest","com.example.locktest.PasswordActivity");
				intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
				mContext.startActivity(intent);
			}
		}
	}

## 组件导出导致钓鱼欺诈：防护

	//在停止的时候提示
	protected void onStop(){
		super.onStop();
		Context context=getApplicationContext();
		Toast toast=Toast.makeText(getApplicationContext(),"程序进入后台",Toast.LENGTH_SHORT);
		toast.show();
	}

	不指定taskAffinity task管理activity。task的名字取决于根activity的affinity。默认设置中Activity使用包名做为affinity。task由app分配，所以一个应用的Activty在默认情况下属于相同task。跨task启动Activity的intent有可能被其他app读取到；不指定lunchMode默认standard，建议使用默认。创建新task时有可能被其他应用读取intent的内容。

	如果当前的程序进入后台那么进行Notification提示用户进程已经进进入后台运行，并且如果有必要可以设置清除通知时候不允许这个通知被清除掉。  

## 隐式启动intent包含敏感数据
没看懂

## 拒绝服务

	Android系统提供了Intent机制来协助应用间的交互与通讯，Intent负责对应用中一次操作的动作、动作涉及数据、附加数据进行描述，Android系统则根据此Intent的描述，负责找到对应的组件，将Intent传递给调用的组件，并完成组件的调用。Android应用本地拒绝服务漏洞源于程序没有对Intent.getXXXExtra()获取的异常或者畸形数据处理时没有进行异常捕获，从而导致攻击者可通过向受害者应用发送此类空数据、异常或者畸形数据来达到使该应用crash的目的，

	简单的说就是攻击者通过intent发送空数据、异常或畸形数据给受害者应用，导致其崩溃。本地拒绝服务漏洞不仅可以导致安全防护等应用的防护功能被绕过或失效(如杀毒应用、安全卫士、防盗锁屏等)，而且也可被竞争方应用利用来攻击，使得自己的应用崩溃，造成不同程度的经济利益损失。  

	危害：拒绝服务漏洞对于锁屏应用、安全防护类软件危害是巨大的。  

## 拒绝服务：防护
	
- 空指针异常
- 类型转换异常
- 数组越界访问异常
- 类未定义异常
- 其他异常

---

	//Serializable:
	Intent i = this.getIntent();
	if(i.getAction().equals("serializable_action")){
		i.getSerializableExtra("serializable_key");//未做异常判断
	}
	//Parcelable:
	this.b=(RouterConfig)this.getIntent().getParcelableExtra("filed_router_config");//引发转型异常崩溃

	谨慎处理接收的intent以及其携带的信息。  
	对接收到的任何数据做try catch处理，以及对不符合预期的数据做异常处理。  
